/*
Copyright 2020 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package cryptolib

import (
	"testing"

	"github.com/pkg/errors"
)

const qualifiedImage = "gcr.io/image/digest@sha256:0000000000000000000000000000000000000000000000000000000000000000"

// This key was generated by the following commands:
// `gpg --quick-generate-key --yes verifier@cryptolib.com`
// `gpg --export --armor verifier@cryptolib.com > verifierPublicKey`
const verifierPublicKey = `-----BEGIN PGP PUBLIC KEY BLOCK-----

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
w084byeM9nc=
=zsax
-----END PGP PUBLIC KEY BLOCK-----`

const verifierPublicKeyID = "446625EB36036D7546B2D63B77B4BE6989834233"

func TestNewPublicKey(t *testing.T) {
	tcs := []struct {
		name              string
		authenticatorType AuthenticatorType
		keyData           []byte
		keyID             string
		expectedErr       bool
		expectedID        string
	}{
		{
			name:              "valid PGP key ID",
			authenticatorType: Pgp,
			keyData:           []byte(verifierPublicKey),
			keyID:             verifierPublicKeyID,
			expectedErr:       false,
			expectedID:        verifierPublicKeyID,
		},
		{
			name:              "incorrect PGP key ID",
			authenticatorType: Pgp,
			keyData:           []byte(verifierPublicKey),
			keyID:             "incorrect-id",
			expectedErr:       false,
			expectedID:        verifierPublicKeyID,
		},
		{
			name:              "valid PKIX key ID",
			authenticatorType: Pkix,
			keyID:             "valid-key-id",
			expectedErr:       false,
			expectedID:        "valid-key-id",
		},
		{
			name:              "invalid PKIX key ID",
			authenticatorType: Pkix,
			keyID:             ":{invalid-key-id}",
			expectedErr:       true,
		},
		{
			name:              "unknown authenticator type",
			authenticatorType: UnknownAuthenticatorType,
			expectedErr:       true,
		},
	}
	for _, tc := range tcs {
		t.Run(tc.name, func(t *testing.T) {
			publicKey, err := NewPublicKey(tc.authenticatorType, tc.keyData, tc.keyID)
			if tc.expectedErr {
				if err == nil {
					t.Errorf("Got nil err, expected not-nil")
				}
			} else {
				if err != nil {
					t.Fatalf("Unexpected error: %v", err)
				}
				if publicKey.ID != tc.expectedID {
					t.Errorf("Got ID: %q, want ID: %q", publicKey.ID, tc.expectedID)
				}
			}
		})
	}
}

func TestVerifyAttestation(t *testing.T) {
	att := &Attestation{
		PublicKeyID:       "key-id",
		Signature:         []byte("signature"),
		SerializedPayload: []byte("payload"),
	}
	matchingKey, err := NewPublicKey(Pkix, []byte("key-data"), "key-id")
	if err != nil {
		t.Fatalf("error creating public key: %v", err)
	}
	otherMatchingKey, err := NewPublicKey(Pkix, []byte("key-data-other"), "key-id")
	if err != nil {
		t.Fatalf("error creating public key: %v", err)
	}
	nonmatchingKey, err := NewPublicKey(Pkix, []byte("key-data-other"), "key-id-other")
	if err != nil {
		t.Fatalf("error creating public key: %v", err)
	}

	tcs := []struct {
		name        string
		att         *Attestation
		publicKeys  []PublicKey
		verifyErr   bool
		expectedErr bool
	}{
		{
			name:        "single key match",
			att:         att,
			publicKeys:  []PublicKey{*matchingKey},
			verifyErr:   false,
			expectedErr: false,
		},
		{
			name:        "matching and nonmatching keys",
			att:         att,
			publicKeys:  []PublicKey{*nonmatchingKey, *matchingKey},
			verifyErr:   false,
			expectedErr: false,
		},
		{
			// This is a possibility with user-provided IDs
			name:        "different keys with same ID",
			att:         att,
			publicKeys:  []PublicKey{*matchingKey, *otherMatchingKey},
			verifyErr:   false,
			expectedErr: false,
		},
		{
			name:        "key not found",
			att:         att,
			publicKeys:  []PublicKey{*nonmatchingKey},
			verifyErr:   false,
			expectedErr: true,
		},
		{
			name:        "error in verification",
			att:         att,
			publicKeys:  []PublicKey{*matchingKey},
			verifyErr:   true,
			expectedErr: true,
		},
	}
	for _, tc := range tcs {
		t.Run(tc.name, func(t *testing.T) {
			v := verifier{ImageDigest: qualifiedImage, PublicKeys: indexPublicKeysByID(tc.publicKeys)}
			v.pkixVerifier = mockPkixVerifier{shouldErr: tc.verifyErr}
			v.authenticatedAttChecker = mockAuthAttChecker{}

			err := v.VerifyAttestation(tc.att)
			if tc.expectedErr != (err != nil) {
				t.Errorf("VerifyAttestation(_) got %v, wanted error? = %v", err, tc.expectedErr)
			}
		})
	}
}

type mockPkixVerifier struct {
	shouldErr bool
}

func (v mockPkixVerifier) verifyPkix([]byte, []byte, []byte) error {
	if v.shouldErr {
		return errors.New("error verifying PKIX")
	}
	return nil
}

type mockAuthAttChecker struct{}

func (c mockAuthAttChecker) checkAuthenticatedAttestation(payload []byte, imageName string, imageDigest string, convert convertFunc) error {
	return nil
}
